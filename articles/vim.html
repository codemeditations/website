<html>
  <head>
    <link
      href="https://fonts.googleapis.com/css?family=IBM+Plex+Serif:400,600"
      rel="stylesheet"
    />
    <link rel="icon" href="favicon.png" sizes="16x16" type="image/png" />
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
    <link rel="stylesheet" type="text/css" href="../index.css" />
    <title>Code Meditations</title>
  </head>
  <body>
    <div class="content">
      <h1>Yearnings in VIM</h1>
      <h2>Customizing a text editor workbench closer to the action</h2>
      <h3><a href="http://www.richardanaya.com/">Richard Anaya</a></h3>
      <p>
        Working with UNIX-like operating systems tends to encourage certain
        behavior in it's users. In contrast to highly specialized GUI
        applications, these systems encourage CLI application use by allowing
        the collaboration of processes via files and piping of text data from
        one to another. It's this environment that most often brings many
        developers into their beloved shell of choice, taking advantage of auto
        completion and a certain conformity of interface in working with
        commands via command flags and options.
      </p>
      <p>
        Despite this penchant many developers like myself have for our command
        line friends, we still find it hard to escape one class of application
        in particular â€” the IDE/code editor. There's a certain thrill of power
        that these applications give us developers when we need them the most.
        Making huge refactorings through handfulls of files, giving deep
        introspection at a hover of a mouse, realtime code analysis. Many of the
        features may even come already operational requiring no setup on the
        users behalf.
      </p>
      <p>
        I used to be a diehard Resharper user in a certain part of my life, at
        this time, C# was my bread and butter, and I loved having this tool.
        While I was selling my soul to Microsoft each day though, I was jumping
        into explorations of dynamic languages like Python and Javascript at
        night. I remember needing tools for these alternative languages and
        found myself looking into tools like Notepad++, Sublime, and eventually
        Atom. I became convinced of the power of tools like this not just in
        making my life easier, but making explorations into non-mainstream
        technology easier to do. One day I don't quite remember, I just stopped
        using Visual Studio. It wasn't that is was bad, or not usable, it's just
        that the collaboration of many people on an editor meant I was not as
        locked down by operating system or interest. It wasn't perfect, and many
        times for the sake of a debugger or some specialized functionality I had
        to return to IDEs. Luckily I eventually got myself into javascript and
        enjoy the power of having wonderful debugger in Chrome so it wasn't too
        painful to live without. Developing with test driven development too
        meant that I was looking at consoles for errors more often than code.
      </p>
      <p>
        For years after using Atom, I came to realize that there's really not
        much a good editor needs to help you be efficient at a human level pace.
      </p>
      <ul>
        <li>
          Autocompletion doesn't need to be language specific, just auto
          completing identifiers is incredibly useful
        </li>
        <li>Syntax highlighting shows obvious structure bugs</li>
        <li>
          Finding files by filename and searching by text is sufficient for
          getting around assuming you have good names in your code
        </li>
        <li>
          Commandline code formatters better for team collaboration and
          formatting specifics really don't belong in an editor
        </li>
        <li>
          Jumping back to most recent files is what I am doing 80% of the time
        </li>
        <li>Responsive editors really do make psychological differencea</li>
        <li>
          Open source packages lead to
          <a href="https://atom.io/packages/activate-power-mode">fun ideas</a>
        </li>
      </ul>
      <p>
        Let me say breifly before this next part I have nothing against someone
        who needs to use a tool for a functionality that can be acheived no
        other way. I also have nothing against VS Code or Atom which I too have
        loved. But i've begun to have this feeling:
      </p>
      <blockquote>
        GUI text editors are fundamentally at odds with the spirit of UNIX
      </blockquote>
      <p>
        I offer that these tools are encouraging us not to think of our projects
        a commanded flows of text information. My most concerning observances
        are as follows:
      </p>
      <ul>
        <li>
          The recreation of terminal emulators inside of GUI editors to make up
          for a problem of attention jumping back and forth several windows
        </li>
        <li>
          The recreation of wheels (to inefficient alternatives) to satify
          non-UNIX platforms
        </li>
        <li>
          IDE specific configuration files creating technology bound projects
        </li>
      </ul>
      <p>
        I think these are symptoms of a philosophical problem that have expanded
        our concept of a tool to outside what's necessary. Don't get me wrong, I
        can recognize that these tools are beautiful, but I don't see these
        tools offering an order of magnituded greater level of capabilities than
        terminal based editors that are much more narrow in functionality and
        closer to the action to the shell that is UNIX-like operating system's
        heart.
      </p>
      <p>My personal outlook on project creation is as follows:</p>
      <ul>
        <li>
          if you can't express your project build in a makefile, you are
          probably doing it wrong or recreating the wheel
        </li>
        <li>
          if you need feedback on the state of your code, file observation and
          terminal output is as concise as it gets and allows powerful change
          detection optimizations.
        </li>
        <li>
          if feedback becomes overwhelming, create new terminal tabs or split
          your terminal up
        </li>
        <li>
          appropriate use of terminal text color is beautiful for signalling
          attention
        </li>
        <li>a text editor should be a simple tool that triggers this system</li>
      </ul>
      <p>
        The types of concerns I think should be relegated to a text editor are
        rather few
      </p>
      <ul>
        <li>How do I navigate a collection of files easily</li>
        <li>How do I see the structure of my code easily</li>
        <li>How do I type my code correctly</li>
        <li>Search and replacing text well</li>
      </ul>
      <p>For VIM in particular I have found these tools exceptionally useful:</p>
      <ul>
	      <li><a href="https://github.com/junegunn/vim-plug">Plug</a> - A simple plugin system for VIM</li>

    </div>
  </body>
</html>
